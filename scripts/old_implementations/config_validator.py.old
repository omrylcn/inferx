"""
Configuration Validation Integration for InferX

This module integrates Pydantic validation into the existing InferX config system:
1. Enhanced config.py with Pydantic validation
2. Template generation with validation
3. Runtime.py integration
"""

import warnings
import yaml
import logging
from pathlib import Path
from typing import Dict, Any, List, Optional, Union

try:
    from pydantic import ValidationError
    from .schemas import (
        InferXCoreConfigSchema,
        TemplateProjectConfigSchema,
        validate_core_config,
        validate_template_config,
        load_and_validate_core_config,
        load_and_validate_template_config
    )
    PYDANTIC_AVAILABLE = True
except ImportError:
    PYDANTIC_AVAILABLE = False
    InferXCoreConfigSchema = None
    TemplateProjectConfigSchema = None

from .exceptions import ConfigurationError

logger = logging.getLogger(__name__)


class EnhancedInferXConfig:
    """
    Enhanced InferX configuration with Pydantic validation
    
    Maintains backward compatibility while adding type safety and validation
    """
    
    def __init__(self, config_path: Optional[Union[str, Path]] = None):
        """Initialize enhanced configuration with validation"""
        self._config_path = config_path
        self._raw_config = {}
        self._validated_config = None
        self._validation_enabled = PYDANTIC_AVAILABLE
        
        # Load configuration hierarchy (existing logic)
        self._load_config_hierarchy()
        
        # Add Pydantic validation if available
        if self._validation_enabled:
            self._apply_pydantic_validation()
    
    def _load_config_hierarchy(self):
        """Load configuration hierarchy (existing implementation)"""
        from .config import InferXConfig
        
        # Use existing config loading logic
        legacy_config = InferXConfig(self._config_path)
        self._config = legacy_config.to_dict()
    
    def _apply_pydantic_validation(self):
        """Apply Pydantic validation to loaded configuration"""
        if not PYDANTIC_AVAILABLE:
            logger.warning("Pydantic not available, skipping enhanced validation")
            return
        
        try:
            # Validate with core config schema
            self._validated_config = validate_core_config(self._config, str(self._config_path) if self._config_path else None)
            
            # Update raw config with validated/default values
            self._config = self._validated_config.dict()
            
            logger.debug("Core configuration validated successfully with Pydantic")
            
        except ValidationError as e:
            # Convert Pydantic errors to user-friendly format
            self._handle_validation_error(e, "core configuration")
    
    def _handle_validation_error(self, error: ValidationError, config_type: str):
        """Convert Pydantic validation errors to user-friendly messages"""
        field_errors = []
        suggestions = []
        
        for err in error.errors():
            field_path = " → ".join(str(loc) for loc in err['loc'])
            field_errors.append({
                'field': field_path,
                'message': err['msg'],
                'type': err['type']
            })
            
            # Add specific suggestions based on error type
            if err['type'] == 'value_error.number.not_ge':
                limit = err.get('ctx', {}).get('limit_value', 0)
                suggestions.append(f"Set '{field_path}' to a value >= {limit}")
            elif err['type'] == 'value_error.number.not_le':
                limit = err.get('ctx', {}).get('limit_value', 1)
                suggestions.append(f"Set '{field_path}' to a value <= {limit}")
            elif 'divisible' in str(err['msg']):
                suggestions.append(f"'{field_path}' must be divisible by 32 for YOLO models")
            elif err['type'] == 'value_error.missing':
                suggestions.append(f"Add required field '{field_path}' to configuration")
        
        raise ConfigurationError(
            message=f"Validation failed for {config_type}",
            field_errors=field_errors,
            suggestions=suggestions
        )
    
    # =============================================================================
    # BACKWARD COMPATIBLE API
    # =============================================================================
    
    def get(self, key_path: str, default: Any = None) -> Any:
        """Get configuration value using dot notation (existing API)"""
        return self._get_nested_value(self._config, key_path, default)
    
    def get_model_defaults(self, model_type: str) -> Dict[str, Any]:
        """Get model defaults with validation"""
        base_type = model_type.split('_')[0]
        defaults = self.get(f"model_defaults.{base_type}", {})
        
        if not defaults:
            available_types = list(self.get("model_defaults", {}).keys())
            raise ConfigurationError(
                f"Model type '{base_type}' not found",
                suggestions=[
                    f"Use one of: {', '.join(available_types)}",
                    f"Add '{base_type}' configuration to model_defaults"
                ]
            )
        
        return defaults
    
    def get_preprocessing_defaults(self, runtime: str) -> Dict[str, Any]:
        """Get preprocessing defaults with validation"""
        return self.get(f"preprocessing_defaults.{runtime}", {})
    
    def get_device_name(self, device: str) -> str:
        """Map device name to runtime-specific name with validation"""
        mapped_device = self.get(f"device_mapping.{device}", device.upper())
        
        # Validate device is supported
        if self._validation_enabled and device not in self.get("device_mapping", {}):
            available_devices = list(self.get("device_mapping", {}).keys())
            logger.warning(
                f"Device '{device}' not in device mapping. "
                f"Available: {', '.join(available_devices)}"
            )
        
        return mapped_device
    
    def detect_model_type(self, model_path: Path, runtime_hint: Optional[str] = None) -> str:
        """Detect model type from path with enhanced logic"""
        from .config import InferXConfig
        
        # Use existing detection logic
        legacy_config = InferXConfig()
        return legacy_config.detect_model_type(model_path, runtime_hint)
    
    def to_dict(self) -> Dict[str, Any]:
        """Get full configuration as dictionary"""
        return self._config.copy()
    
    # =============================================================================
    # NEW TYPED API
    # =============================================================================
    
    @property
    def typed(self) -> Optional[InferXCoreConfigSchema]:
        """Type-safe access to configuration"""
        if not self._validation_enabled:
            warnings.warn(
                "Typed configuration access requires Pydantic. "
                "Install with: pip install pydantic",
                UserWarning
            )
            return None
        
        return self._validated_config
    
    def validate(self) -> List[str]:
        """Validate configuration and return warnings"""
        warnings = []
        
        if not self._validation_enabled:
            warnings.append("Enhanced validation unavailable (Pydantic not installed)")
            return warnings
        
        try:
            validate_core_config(self._config)
        except ValidationError as e:
            for error in e.errors():
                field = " → ".join(str(loc) for loc in error['loc'])
                warnings.append(f"{field}: {error['msg']}")
        
        return warnings
    
    # =============================================================================
    # HELPER METHODS
    # =============================================================================
    
    def _get_nested_value(self, config: Dict, key_path: str, default: Any = None) -> Any:
        """Get nested configuration value"""
        keys = key_path.split('.')
        value = config
        
        try:
            for key in keys:
                value = value[key]
            return value
        except (KeyError, TypeError):
            return default


class TemplateConfigValidator:
    """
    Validator for template project configurations
    
    Used during template generation to ensure generated config.yaml files are valid
    """
    
    @staticmethod
    def validate_template_config_data(config_data: Dict[str, Any], template_type: str) -> TemplateProjectConfigSchema:
        """
        Validate template configuration data
        
        Args:
            config_data: Configuration dictionary
            template_type: Type of template (yolo, classification, etc.)
            
        Returns:
            Validated template configuration
            
        Raises:
            ConfigurationError: If validation fails
        """
        if not PYDANTIC_AVAILABLE:
            logger.warning("Pydantic not available, skipping template validation")
            return config_data
        
        try:
            return validate_template_config(config_data)
        except ValidationError as e:
            # Convert to user-friendly error
            field_errors = []
            suggestions = []
            
            for err in e.errors():
                field_path = " → ".join(str(loc) for loc in err['loc'])
                field_errors.append({
                    'field': field_path,
                    'message': err['msg'],
                    'type': err['type']
                })
                
                # Template-specific suggestions
                if 'model' in field_path and 'path' in field_path:
                    suggestions.append("Ensure model path points to a valid model file")
                elif 'input_size' in field_path and 'divisible' in err['msg']:
                    suggestions.append("Use input sizes divisible by 32 (e.g., 320, 416, 512, 640, 1024)")
                elif 'confidence_threshold' in field_path:
                    suggestions.append("Set confidence threshold between 0.0 and 1.0")
            
            raise ConfigurationError(
                message=f"Template configuration validation failed for {template_type} template",
                field_errors=field_errors,
                suggestions=suggestions
            )
    
    @staticmethod
    def validate_template_config_file(config_path: Union[str, Path]) -> TemplateProjectConfigSchema:
        """
        Validate template configuration file
        
        Args:
            config_path: Path to template config.yaml file
            
        Returns:
            Validated template configuration
        """
        if not PYDANTIC_AVAILABLE:
            logger.warning("Pydantic not available, skipping template file validation")
            return {}
        
        try:
            return load_and_validate_template_config(config_path)
        except Exception as e:
            raise ConfigurationError(
                message=f"Failed to validate template configuration file: {config_path}",
                suggestions=[
                    "Check YAML syntax",
                    "Ensure all required fields are present",
                    "Verify model path is correct"
                ],
                original_error=e
            )
    
    @staticmethod
    def create_validated_template_config(
        model_type: str,
        model_path: str,
        project_name: str,
        **options
    ) -> Dict[str, Any]:
        """
        Create a validated template configuration
        
        Args:
            model_type: Type of model (yolo, classification, etc.)
            model_path: Path to model file
            project_name: Name of the project
            **options: Additional configuration options
            
        Returns:
            Validated configuration dictionary
        """
        # Create base configuration
        config_data = {
            "model": {
                "path": model_path,
                "type": model_type
            },
            "inference": {
                "device": options.get("device", "auto"),
                "runtime": options.get("runtime", "auto"),
                "confidence_threshold": options.get("confidence_threshold", 0.25)
            },
            "preprocessing": {
                "target_size": [640, 640] if model_type.startswith("yolo") else [224, 224],
                "normalize": True,
                "color_format": "RGB",
                "maintain_aspect_ratio": True
            }
        }
        
        # Add model-specific settings
        if model_type.startswith("yolo"):
            config_data["inference"]["nms_threshold"] = options.get("nms_threshold", 0.45)
            config_data["inference"]["input_size"] = options.get("input_size", 640)
        
        # Validate the created configuration
        validated_config = TemplateConfigValidator.validate_template_config_data(
            config_data, model_type
        )
        
        return validated_config.dict() if hasattr(validated_config, 'dict') else config_data


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================

def get_enhanced_config(config_path: Optional[Union[str, Path]] = None) -> EnhancedInferXConfig:
    """
    Get enhanced configuration instance with Pydantic validation
    
    This is a drop-in replacement for the existing get_config() function
    """
    return EnhancedInferXConfig(config_path)


def validate_user_config_file(config_path: Union[str, Path]) -> bool:
    """
    Validate a user configuration file
    
    Args:
        config_path: Path to configuration file
        
    Returns:
        True if valid, False otherwise
    """
    try:
        if PYDANTIC_AVAILABLE:
            load_and_validate_core_config(config_path)
        logger.info(f"Configuration file is valid: {config_path}")
        return True
    except Exception as e:
        logger.error(f"Configuration file validation failed: {e}")
        return False


if __name__ == "__main__":
    # Demo usage
    print("Enhanced InferX Configuration with Pydantic Validation")
    print("=" * 60)
    
    try:
        # Test core config validation
        config = get_enhanced_config()
        print("✅ Core configuration loaded and validated")
        
        # Test typed access
        if config.typed:
            yolo_defaults = config.typed.model_defaults.yolo
            print(f"✅ YOLO confidence threshold: {yolo_defaults.confidence_threshold}")
            print(f"✅ YOLO input size: {yolo_defaults.input_size}")
        
        # Test template config validation
        sample_template = {
            "model": {"path": "models/yolo_model.onnx", "type": "yolo"},
            "inference": {"device": "auto", "confidence_threshold": 0.25, "input_size": 640},
            "preprocessing": {"target_size": [640, 640], "normalize": True}
        }
        
        validated_template = TemplateConfigValidator.validate_template_config_data(
            sample_template, "yolo"
        )
        print("✅ Template configuration validation successful")
        
    except Exception as e:
        print(f"❌ Validation failed: {e}")
    
    print("\n🎯 Key Benefits:")
    print("   • Type-safe configuration access")
    print("   • Automatic validation with detailed error messages")
    print("   • Backward compatibility with existing API")
    print("   • Template configuration validation")
    print("   • Enhanced error handling and suggestions")